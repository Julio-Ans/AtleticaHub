const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();
const { bucket } = require('../config/firebaseAdmin');
const uploadService = require('../services/uploadService');
const produtoService = require('../services/produtoService'); // Seu servi√ßo para acessar dados de produtos no DB
const recomendacaoService = require('../services/recomendacaoService');

const criarProduto = async (req, res) => {
  try {
    const { nome, descricao, preco, estoque } = req.body;
    const imagem = req.file;

    if (!nome || !descricao || !preco || !estoque || !imagem) {
      return res.status(400).json({ error: 'Todos os campos s√£o obrigat√≥rios.' });
    }    // Usar uploadService para consist√™ncia com eventos/esportes
    const imagemUrl = await uploadService.uploadFile(
      imagem.buffer,
      imagem.originalname,
      'produtos'
    );

    const novoProduto = await prisma.produto.create({
      data: {
        nome,
        descricao,
        preco: parseFloat(preco),
        estoque: parseInt(estoque),
        imagemUrl
      }
    });

    res.status(201).json({ message: 'Produto criado com sucesso', produto: novoProduto });
  } catch (err) {
    console.error('Erro ao criar produto:', err);
    res.status(500).json({ error: 'Erro interno ao cadastrar o produto' });
  }
};


const listarProdutos = async (req, res) => {
  try {
    const produtos = await prisma.produto.findMany();
    res.status(200).json(produtos);
  } catch (err) {
    res.status(500).json({ error: 'Erro ao listar produtos' });
  }
};

const detalharProduto = async (req, res) => {
  try {
    const { id } = req.params;
    const produto = await prisma.produto.findUnique({ where: { id: parseInt(id) } });

    if (!produto) {
      return res.status(404).json({ error: 'Produto n√£o encontrado' });
    }

    res.status(200).json(produto);
  } catch (err) {
    res.status(500).json({ error: 'Erro ao buscar produto' });
  }
};

const editarProduto = async (req, res) => {
  try {
    const { id } = req.params;
    const { nome, descricao, preco, estoque } = req.body;

    const dadosAtualizados = {
      nome,
      descricao,
      preco: parseFloat(preco),
      estoque: parseInt(estoque)
    };

    const produto = await prisma.produto.findUnique({
      where: { id: parseInt(id) }
    });

    if (!produto) {
      return res.status(404).json({ error: 'Produto n√£o encontrado' });
    }    // Se o admin enviou uma nova imagem, salva no Firebase
    if (req.file) {
      // Exclui imagem anterior, se houver
      if (produto.imagemUrl) {
        try {
          await uploadService.deleteFile(produto.imagemUrl);
        } catch (err) {
          // S√≥ mostra warning se n√£o for erro 404 (arquivo n√£o encontrado)
          if (!(err.code === 404 || err.code === '404' || err.message?.includes('No such object'))) {
            console.warn('‚ö†Ô∏è Falha ao remover imagem antiga do Firebase:', err.message);
          }
        }
      }// Usar uploadService para consist√™ncia
      dadosAtualizados.imagemUrl = await uploadService.uploadFile(
        req.file.buffer,
        req.file.originalname,
        'produtos'
      );
    }

    // Atualiza produto no Prisma
    const produtoAtualizado = await prisma.produto.update({
      where: { id: parseInt(id) },
      data: dadosAtualizados
    });

    res.status(200).json(produtoAtualizado);
  } catch (err) {
    console.error('Erro ao editar produto:', err);
    res.status(500).json({ error: 'Erro ao editar produto' });
  }
};

const deletarProduto = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('üóëÔ∏è Iniciando exclus√£o do produto ID:', id);

    if (!id || isNaN(id)) {
      return res.status(400).json({ error: "ID inv√°lido" });
    }

    // Busca o produto antes de deletar para pegar o nome da imagem
    const produto = await prisma.produto.findUnique({
      where: { id: parseInt(id) }
    });

    if (!produto) {
      return res.status(404).json({ error: 'Produto n√£o encontrado' });
    }

    console.log('üì¶ Produto encontrado:', produto.nome);

    // Extrai o caminho da imagem do Firebase e remove usando uploadService
    if (produto.imagemUrl) {
      try {
        await uploadService.deleteFile(produto.imagemUrl);
        console.log('üñºÔ∏è Imagem removida do Firebase');
      } catch (err) {
        // S√≥ mostra warning se n√£o for erro 404 (arquivo n√£o encontrado)
        if (!(err.code === 404 || err.code === '404' || err.message?.includes('No such object'))) {
          console.warn('‚ö†Ô∏è Falha ao remover imagem do Firebase:', err.message);
        }
        console.log('üñºÔ∏è Imagem n√£o encontrada no Firebase (ignorado)');
      }
    }    // Remove todos os itens de carrinho que referenciam este produto
    const itensCarrinhoRemovidos = await prisma.cartItem.deleteMany({
      where: { produtoId: parseInt(id) }
    });
    console.log('üõí Itens de carrinho removidos:', itensCarrinhoRemovidos.count);

    // Verifica se h√° pedidos vinculados e remove as rela√ß√µes
    const pedidosVinculados = await prisma.pedidoProduto.findMany({
      where: { produtoId: parseInt(id) }
    });

    if (pedidosVinculados.length > 0) {
      console.log('‚ö†Ô∏è Produto vinculado a pedidos:', pedidosVinculados.length);
      console.log('üóëÔ∏è Removendo rela√ß√µes produto-pedido...');
      
      // Remove todas as rela√ß√µes produto-pedido
      const relacoesRemovidas = await prisma.pedidoProduto.deleteMany({
        where: { produtoId: parseInt(id) }
      });
      console.log('üóëÔ∏è Rela√ß√µes produto-pedido removidas:', relacoesRemovidas.count);
    }

    console.log('‚úÖ Prosseguindo com exclus√£o do produto...');

    // Remove o produto do banco
    const produtoExcluido = await prisma.produto.delete({
      where: { id: parseInt(id) }
    });

    console.log('‚úÖ Produto exclu√≠do do banco:', produtoExcluido.id);
    res.status(200).json({ message: 'Produto exclu√≠do com sucesso' });  } catch (err) {
    console.error('‚ùå Erro ao excluir produto:', err);
    res.status(500).json({ error: err.message });
  }
};

async function getProdutoDetalhesComRecomendacoes(req, res) {
  const { id } = req.params; // ID do produto que o usu√°rio est√° vendo
  const quantidadeRecomendacoes = parseInt(req.query.quantidade || '3');

  try {
    const produto = await produtoService.detalharProduto(id);
    if (!produto) {
      return res.status(404).json({ message: 'Produto n√£o encontrado.' });
    }

    const interacoesDosClientesComProdutos = await produtoService.getInteracoesParaRecomendador();

    if (!interacoesDosClientesComProdutos || interacoesDosClientesComProdutos.length === 0) {
        return res.status(200).json({
            produto: produto,
            recomendados: [],
            message: "N√£o h√° dados de intera√ß√£o suficientes para gerar recomenda√ß√µes."
        });
    }

    const nomesDosRecomendados = await recomendacaoService.getRecommendations(
      interacoesDosClientesComProdutos,
      produto.nome,
      quantidadeRecomendacoes
    );

    let produtosRecomendadosCompletos = [];
    if (nomesDosRecomendados && nomesDosRecomendados.length > 0) {
      // Buscar os detalhes completos dos produtos recomendados
      produtosRecomendadosCompletos = await prisma.produto.findMany({
        where: {
          nome: {
            in: nomesDosRecomendados
          }
        }
      });
      // Opcional: Manter a ordem original dos recomendados, se necess√°rio
      // Isto pode ser importante se a ordem da ML service for relevante
      produtosRecomendadosCompletos.sort((a, b) => {
        return nomesDosRecomendados.indexOf(a.nome) - nomesDosRecomendados.indexOf(b.nome);
      });
    }

    return res.status(200).json({
      produto: produto,
      recomendados: produtosRecomendadosCompletos, // Agora envia os objetos completos
    });

  } catch (error) {
    console.error('Erro ao obter detalhes do produto e recomenda√ß√µes:', error);
    return res.status(500).json({ message: 'Erro interno do servidor ao processar sua requisi√ß√£o.' });
  }
}

// Nova fun√ß√£o para o controller
const atualizarImagensProdutosAleatoriamente = async (req, res) => {
  try {
    // Chamar o servi√ßo para atualizar as imagens
    const resultado = await produtoService.atualizarTodasAsImagensDeProdutosAleatoriamente();
    
    // Verificar se houve erros no processo do servi√ßo
    if (resultado.erros > 0 && resultado.atualizados === 0) {
      // Se apenas erros ocorreram, pode ser um erro 500 ou 404 dependendo da natureza
      // Se nenhum produto foi encontrado, o servi√ßo j√° retorna uma mensagem espec√≠fica.
      return res.status(500).json({ 
        message: resultado.mensagem || 'Falha ao atualizar imagens dos produtos.',
        detalhes: resultado
      });
    }

    if (resultado.atualizados === 0 && resultado.erros === 0 && resultado.mensagem.includes('Nenhum produto')){
        return res.status(404).json({message: resultado.mensagem, detalhes: resultado });
    }

    // Se chegou aqui, pelo menos algumas atualiza√ß√µes podem ter ocorrido
    res.status(200).json({
      message: resultado.mensagem || 'Processo de atualiza√ß√£o de imagens conclu√≠do.',
      detalhes: resultado
    });

  } catch (error) {
    console.error('Erro no controller ao tentar atualizar imagens dos produtos:', error);
    res.status(500).json({ 
      message: 'Erro interno do servidor ao tentar atualizar imagens dos produtos.',
      error: error.message 
    });
  }
};

module.exports = {
  criarProduto,
  listarProdutos,
  detalharProduto,
  editarProduto,
  deletarProduto,
  getProdutoDetalhesComRecomendacoes,
  atualizarImagensProdutosAleatoriamente // Adicionar a nova fun√ß√£o aqui
};
